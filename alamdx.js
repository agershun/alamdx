//
// alamdx.js
// Alasql - JavaScript MDX OLAP lobrary
// Date: 23.11.2014
// Version: 0.0.0
// (Ã±) 2014, Andrey Gershun
//

/*
The MIT License (MIT)

Copyright (c) 2014 Andrey Gershun (agershun@gmail.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

//  UMD header
(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        define(['alasql'], factory);
    } else if (typeof exports === 'object') {
        module.exports = factory(require('alasql'));
    } else {
        root.alamdx = factory(root.alasql);
    }
}(this, function (alasql) {

// Main function
alamdx = function(mdx, params, cb, scope) {
	return alamdx.exec(mdx, params, cb, scope);
};

// For co-existense of alasql and alamdx
alamdx.alasql = alasql;



/* parser generated by jison 0.4.15 */
/*
  Returns a Parser object of the following structure:

  Parser: {
    yy: {}
  }

  Parser.prototype: {
    yy: {},
    trace: function(),
    symbols_: {associative list: name ==> number},
    terminals_: {associative list: number ==> name},
    productions_: [...],
    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),
    table: [...],
    defaultActions: {...},
    parseError: function(str, hash),
    parse: function(input),

    lexer: {
        EOF: 1,
        parseError: function(str, hash),
        setInput: function(input),
        input: function(),
        unput: function(str),
        more: function(),
        less: function(n),
        pastInput: function(),
        upcomingInput: function(),
        showPosition: function(),
        test_match: function(regex_match_array, rule_index),
        next: function(),
        lex: function(),
        begin: function(condition),
        popState: function(),
        _currentRules: function(),
        topState: function(),
        pushState: function(condition),

        options: {
            ranges: boolean           (optional: true ==> token location info will include a .range[] member)
            flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)
            backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)
        },

        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),
        rules: [...],
        conditions: {associative list: name ==> set},
    }
  }


  token location info (@$, _$, etc.): {
    first_line: n,
    last_line: n,
    first_column: n,
    last_column: n,
    range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)
  }


  the parseError function receives a 'hash' object with these members for lexer and parser errors: {
    text:        (matched text)
    token:       (the produced terminal token, if any)
    line:        (yylineno)
  }
  while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {
    loc:         (yylloc)
    expected:    (string describing the set of expected tokens)
    recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)
  }
*/
var parser = (function(){
var o=function(k,v,o,l){for(o=o||{},l=k.length;l--;o[k[l]]=v);return o},$V0=[9,10],$V1=[2,7],$V2=[1,7],$V3=[1,8],$V4=[1,21],$V5=[1,22],$V6=[1,23],$V7=[1,18],$V8=[1,19],$V9=[9,10,55],$Va=[21,43],$Vb=[1,30],$Vc=[1,31],$Vd=[1,37],$Ve=[9,10,21,24,33,39,40,41,46,47,48,49,50,51,52,53,54,55],$Vf=[2,27],$Vg=[9,10,21,24,31,33,39,40,41,44,46,47,48,49,50,51,52,53,54,55],$Vh=[1,56],$Vi=[21,33,39],$Vj=[1,57],$Vk=[1,59],$Vl=[1,60],$Vm=[1,61],$Vn=[1,62],$Vo=[1,63],$Vp=[1,64],$Vq=[1,65],$Vr=[1,66],$Vs=[1,67],$Vt=[9,10,21,33,39,40,41,46,47,48,49,50,51,52,53,54,55],$Vu=[4,5,6,37],$Vv=[9,10,21,33,39,55],$Vw=[2,28];
var parser = {trace: function trace() { },
yy: {},
symbols_: {"error":2,"Literal":3,"LITERAL":4,"BRALITERAL":5,"AMPERSAND":6,"main":7,"MdxStatements":8,"EOF":9,"SEMICOLON":10,"MdxStatement":11,"Select":12,"WithSelect":13,"WITH":14,"SelectClause":15,"FromClause":16,"HavingClause":17,"WhereClause":18,"SELECT":19,"OnList":20,"COMMA":21,"OnClause":22,"SetClause":23,"ON":24,"ROWS":25,"COLUMNS":26,"PAGES":27,"SECTIONS":28,"CHAPTERS":29,"AXIS":30,"LPAR":31,"NUMBER":32,"RPAR":33,"Set":34,"NON":35,"EMPTY":36,"LCUR":37,"ExprList":38,"RCUR":39,"DOT":40,"STAR":41,"Expression":42,"FROM":43,"HAVING":44,"Op":45,"SLASH":46,"PLUS":47,"MINUS":48,"GT":49,"GE":50,"LT":51,"LE":52,"EQ":53,"NE":54,"WHERE":55,"$accept":0,"$end":1},
terminals_: {2:"error",4:"LITERAL",5:"BRALITERAL",6:"AMPERSAND",9:"EOF",10:"SEMICOLON",14:"WITH",19:"SELECT",21:"COMMA",24:"ON",25:"ROWS",26:"COLUMNS",27:"PAGES",28:"SECTIONS",29:"CHAPTERS",30:"AXIS",31:"LPAR",32:"NUMBER",33:"RPAR",35:"NON",36:"EMPTY",37:"LCUR",39:"RCUR",40:"DOT",41:"STAR",43:"FROM",44:"HAVING",46:"SLASH",47:"PLUS",48:"MINUS",49:"GT",50:"GE",51:"LT",52:"LE",53:"EQ",54:"NE",55:"WHERE"},
productions_: [0,[3,1],[3,1],[3,2],[7,2],[8,3],[8,1],[11,0],[11,1],[11,1],[13,2],[12,4],[15,2],[20,3],[20,1],[22,3],[22,3],[22,3],[22,3],[22,3],[22,6],[22,3],[23,1],[23,3],[34,3],[34,3],[34,3],[34,1],[34,4],[38,3],[38,1],[38,3],[38,1],[16,2],[17,2],[17,0],[42,1],[42,3],[42,3],[42,4],[45,1],[45,1],[45,1],[45,1],[45,1],[45,1],[45,1],[45,1],[45,1],[45,1],[18,2],[18,0]],
performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {
/* this == yyval */

var $0 = $$.length - 1;
switch (yystate) {
case 1:

			if (yy.casesensitive) this.$ = $$[$0];
			else this.$ = $$[$0].toLowerCase();
		
break;
case 2:
 this.$ = alasql.utils.doubleq($$[$0].substr(1,$$[$0].length-2)); 
break;
case 3:
 this.$ = alasql.utils.doubleq($$[$0-1].substr(1,$$[$0-1].length-2)); 
break;
case 4:
 
		//return new yy.MdxStatements({statements:$$[$0-1]}); 
		
break;
case 5:
 this.$ = $$[$0-2]; if($$[$0]) $$[$0-2].push($$[$0]); 
break;
case 6:
 this.$ = [$$[$0]]; 
break;
case 7:
 this.$ = null; 
break;
case 11:
 this.$ = $$[$0-3] 
break;
case 33:
 this.$ = $$[$0-1]; 
break;
}
},
table: [o($V0,$V1,{7:1,8:2,11:3,12:4,13:5,15:6,14:$V2,19:$V3}),{1:[3]},{9:[1,9],10:[1,10]},o($V0,[2,6]),o($V0,[2,8]),o($V0,[2,9]),{16:11,43:[1,12]},{12:13,15:6,19:$V3},{3:20,4:$V4,5:$V5,6:$V6,20:14,22:15,23:16,34:17,35:$V7,37:$V8},{1:[2,4]},o($V0,$V1,{12:4,13:5,15:6,11:24,14:$V2,19:$V3}),o($V9,[2,35],{17:25,44:[1,26]}),{3:27,4:$V4,5:$V5,6:$V6},o($V0,[2,10]),{21:[1,28],43:[2,12]},o($Va,[2,14]),{24:[1,29]},{24:[2,22],40:$Vb,41:$Vc},{36:[1,32]},{3:36,4:$V4,5:$V5,6:$V6,31:$Vd,34:34,37:$V8,38:33,42:35},o($Ve,$Vf,{31:[1,38]}),o($Vg,[2,1]),o($Vg,[2,2]),{5:[1,39]},o($V0,[2,5]),o($V0,[2,51],{18:40,55:[1,41]}),{3:36,4:$V4,5:$V5,6:$V6,31:$Vd,34:43,37:$V8,42:42},o([9,10,44,55],[2,33]),{3:20,4:$V4,5:$V5,6:$V6,22:44,23:16,34:17,35:$V7,37:$V8},{25:[1,45],26:[1,46],27:[1,47],28:[1,48],29:[1,49],30:[1,50],32:[1,51]},{3:20,4:$V4,5:$V5,6:$V6,34:52,37:$V8},{3:20,4:$V4,5:$V5,6:$V6,34:53,37:$V8},{3:20,4:$V4,5:$V5,6:$V6,34:54,37:$V8},{21:$Vh,39:[1,55]},o($Vi,[2,30],{45:58,40:$Vb,41:$Vj,46:$Vk,47:$Vl,48:$Vm,49:$Vn,50:$Vo,51:$Vp,52:$Vq,53:$Vr,54:$Vs}),o($Vi,[2,32]),o($Vt,$Vf,{31:[1,68]}),{3:36,4:$V4,5:$V5,6:$V6,31:$Vd,34:43,37:$V8,42:69},{3:36,4:$V4,5:$V5,6:$V6,31:$Vd,34:34,37:$V8,38:70,42:35},o($Vg,[2,3]),o($V0,[2,11]),{3:36,4:$V4,5:$V5,6:$V6,31:$Vd,34:43,37:$V8,42:71},o($V9,[2,34]),o([9,10,33,55],[2,36],{45:58,40:$Vb,41:$Vj,46:$Vk,47:$Vl,48:$Vm,49:$Vn,50:$Vo,51:$Vp,52:$Vq,53:$Vr,54:$Vs}),o($Va,[2,13]),o($Va,[2,15]),o($Va,[2,16]),o($Va,[2,17]),o($Va,[2,18]),o($Va,[2,19]),{31:[1,72]},o($Va,[2,21]),o($Ve,[2,25]),o([9,10,21,24,33,39,41,46,47,48,49,50,51,52,53,54,55],[2,26],{40:$Vb}),{24:[2,23],40:$Vb,41:$Vc},o($Ve,[2,24]),{3:36,4:$V4,5:$V5,6:$V6,31:$Vd,34:73,37:$V8,42:74},{3:20,4:$V4,5:$V5,6:$V6,34:53,37:$V8},{3:20,4:$V4,5:$V5,6:$V6,34:75,37:$V8},o($Vu,[2,41]),o($Vu,[2,42]),o($Vu,[2,43]),o($Vu,[2,44]),o($Vu,[2,45]),o($Vu,[2,46]),o($Vu,[2,47]),o($Vu,[2,48]),o($Vu,[2,49]),{3:36,4:$V4,5:$V5,6:$V6,31:$Vd,34:34,37:$V8,38:76,42:35},{33:[1,77]},{21:$Vh,33:[1,78]},o($V0,[2,50]),{32:[1,79]},o($Vi,[2,29],{45:58,40:$Vb,41:$Vj,46:$Vk,47:$Vl,48:$Vm,49:$Vn,50:$Vo,51:$Vp,52:$Vq,53:$Vr,54:$Vs}),o($Vi,[2,31]),o($Vv,[2,37],{40:$Vb,41:$Vc}),{21:$Vh,33:[1,80]},o($Vv,[2,38]),o($Ve,$Vw),{33:[1,81]},o($Vt,$Vw),o($Va,[2,20])],
defaultActions: {9:[2,4]},
parseError: function parseError(str, hash) {
    if (hash.recoverable) {
        this.trace(str);
    } else {
        throw new Error(str);
    }
},
parse: function parse(input) {
    var self = this, stack = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = '', yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;
    var args = lstack.slice.call(arguments, 1);
    var lexer = Object.create(this.lexer);
    var sharedState = { yy: {} };
    for (var k in this.yy) {
        if (Object.prototype.hasOwnProperty.call(this.yy, k)) {
            sharedState.yy[k] = this.yy[k];
        }
    }
    lexer.setInput(input, sharedState.yy);
    sharedState.yy.lexer = lexer;
    sharedState.yy.parser = this;
    if (typeof lexer.yylloc == 'undefined') {
        lexer.yylloc = {};
    }
    var yyloc = lexer.yylloc;
    lstack.push(yyloc);
    var ranges = lexer.options && lexer.options.ranges;
    if (typeof sharedState.yy.parseError === 'function') {
        this.parseError = sharedState.yy.parseError;
    } else {
        this.parseError = Object.getPrototypeOf(this).parseError;
    }
    function popStack(n) {
        stack.length = stack.length - 2 * n;
        vstack.length = vstack.length - n;
        lstack.length = lstack.length - n;
    }
    _token_stack:
        function lex() {
            var token;
            token = lexer.lex() || EOF;
            if (typeof token !== 'number') {
                token = self.symbols_[token] || token;
            }
            return token;
        }
    var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;
    while (true) {
        state = stack[stack.length - 1];
        if (this.defaultActions[state]) {
            action = this.defaultActions[state];
        } else {
            if (symbol === null || typeof symbol == 'undefined') {
                symbol = lex();
            }
            action = table[state] && table[state][symbol];
        }
                    if (typeof action === 'undefined' || !action.length || !action[0]) {
                var errStr = '';
                expected = [];
                for (p in table[state]) {
                    if (this.terminals_[p] && p > TERROR) {
                        expected.push('\'' + this.terminals_[p] + '\'');
                    }
                }
                if (lexer.showPosition) {
                    errStr = 'Parse error on line ' + (yylineno + 1) + ':\n' + lexer.showPosition() + '\nExpecting ' + expected.join(', ') + ', got \'' + (this.terminals_[symbol] || symbol) + '\'';
                } else {
                    errStr = 'Parse error on line ' + (yylineno + 1) + ': Unexpected ' + (symbol == EOF ? 'end of input' : '\'' + (this.terminals_[symbol] || symbol) + '\'');
                }
                this.parseError(errStr, {
                    text: lexer.match,
                    token: this.terminals_[symbol] || symbol,
                    line: lexer.yylineno,
                    loc: yyloc,
                    expected: expected
                });
            }
        if (action[0] instanceof Array && action.length > 1) {
            throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);
        }
        switch (action[0]) {
        case 1:
            stack.push(symbol);
            vstack.push(lexer.yytext);
            lstack.push(lexer.yylloc);
            stack.push(action[1]);
            symbol = null;
            if (!preErrorSymbol) {
                yyleng = lexer.yyleng;
                yytext = lexer.yytext;
                yylineno = lexer.yylineno;
                yyloc = lexer.yylloc;
                if (recovering > 0) {
                    recovering--;
                }
            } else {
                symbol = preErrorSymbol;
                preErrorSymbol = null;
            }
            break;
        case 2:
            len = this.productions_[action[1]][1];
            yyval.$ = vstack[vstack.length - len];
            yyval._$ = {
                first_line: lstack[lstack.length - (len || 1)].first_line,
                last_line: lstack[lstack.length - 1].last_line,
                first_column: lstack[lstack.length - (len || 1)].first_column,
                last_column: lstack[lstack.length - 1].last_column
            };
            if (ranges) {
                yyval._$.range = [
                    lstack[lstack.length - (len || 1)].range[0],
                    lstack[lstack.length - 1].range[1]
                ];
            }
            r = this.performAction.apply(yyval, [
                yytext,
                yyleng,
                yylineno,
                sharedState.yy,
                action[1],
                vstack,
                lstack
            ].concat(args));
            if (typeof r !== 'undefined') {
                return r;
            }
            if (len) {
                stack = stack.slice(0, -1 * len * 2);
                vstack = vstack.slice(0, -1 * len);
                lstack = lstack.slice(0, -1 * len);
            }
            stack.push(this.productions_[action[1]][0]);
            vstack.push(yyval.$);
            lstack.push(yyval._$);
            newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
            stack.push(newState);
            break;
        case 3:
            return true;
        }
    }
    return true;
}};
/* generated by jison-lex 0.3.4 */
var lexer = (function(){
var lexer = ({

EOF:1,

parseError:function parseError(str, hash) {
        if (this.yy.parser) {
            this.yy.parser.parseError(str, hash);
        } else {
            throw new Error(str);
        }
    },

// resets the lexer, sets new input
setInput:function (input, yy) {
        this.yy = yy || this.yy || {};
        this._input = input;
        this._more = this._backtrack = this.done = false;
        this.yylineno = this.yyleng = 0;
        this.yytext = this.matched = this.match = '';
        this.conditionStack = ['INITIAL'];
        this.yylloc = {
            first_line: 1,
            first_column: 0,
            last_line: 1,
            last_column: 0
        };
        if (this.options.ranges) {
            this.yylloc.range = [0,0];
        }
        this.offset = 0;
        return this;
    },

// consumes and returns one char from the input
input:function () {
        var ch = this._input[0];
        this.yytext += ch;
        this.yyleng++;
        this.offset++;
        this.match += ch;
        this.matched += ch;
        var lines = ch.match(/(?:\r\n?|\n).*/g);
        if (lines) {
            this.yylineno++;
            this.yylloc.last_line++;
        } else {
            this.yylloc.last_column++;
        }
        if (this.options.ranges) {
            this.yylloc.range[1]++;
        }

        this._input = this._input.slice(1);
        return ch;
    },

// unshifts one char (or a string) into the input
unput:function (ch) {
        var len = ch.length;
        var lines = ch.split(/(?:\r\n?|\n)/g);

        this._input = ch + this._input;
        this.yytext = this.yytext.substr(0, this.yytext.length - len);
        //this.yyleng -= len;
        this.offset -= len;
        var oldLines = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1);
        this.matched = this.matched.substr(0, this.matched.length - 1);

        if (lines.length - 1) {
            this.yylineno -= lines.length - 1;
        }
        var r = this.yylloc.range;

        this.yylloc = {
            first_line: this.yylloc.first_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.first_column,
            last_column: lines ?
                (lines.length === oldLines.length ? this.yylloc.first_column : 0)
                 + oldLines[oldLines.length - lines.length].length - lines[0].length :
              this.yylloc.first_column - len
        };

        if (this.options.ranges) {
            this.yylloc.range = [r[0], r[0] + this.yyleng - len];
        }
        this.yyleng = this.yytext.length;
        return this;
    },

// When called from action, caches matched text and appends it on next action
more:function () {
        this._more = true;
        return this;
    },

// When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
reject:function () {
        if (this.options.backtrack_lexer) {
            this._backtrack = true;
        } else {
            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n' + this.showPosition(), {
                text: "",
                token: null,
                line: this.yylineno
            });

        }
        return this;
    },

// retain first n characters of the match
less:function (n) {
        this.unput(this.match.slice(n));
    },

// displays already matched input, i.e. for error messages
pastInput:function () {
        var past = this.matched.substr(0, this.matched.length - this.match.length);
        return (past.length > 20 ? '...':'') + past.substr(-20).replace(/\n/g, "");
    },

// displays upcoming input, i.e. for error messages
upcomingInput:function () {
        var next = this.match;
        if (next.length < 20) {
            next += this._input.substr(0, 20-next.length);
        }
        return (next.substr(0,20) + (next.length > 20 ? '...' : '')).replace(/\n/g, "");
    },

// displays the character position where the lexing error occurred, i.e. for error messages
showPosition:function () {
        var pre = this.pastInput();
        var c = new Array(pre.length + 1).join("-");
        return pre + this.upcomingInput() + "\n" + c + "^";
    },

// test the lexed token: return FALSE when not a match, otherwise return token
test_match:function (match, indexed_rule) {
        var token,
            lines,
            backup;

        if (this.options.backtrack_lexer) {
            // save context
            backup = {
                yylineno: this.yylineno,
                yylloc: {
                    first_line: this.yylloc.first_line,
                    last_line: this.last_line,
                    first_column: this.yylloc.first_column,
                    last_column: this.yylloc.last_column
                },
                yytext: this.yytext,
                match: this.match,
                matches: this.matches,
                matched: this.matched,
                yyleng: this.yyleng,
                offset: this.offset,
                _more: this._more,
                _input: this._input,
                yy: this.yy,
                conditionStack: this.conditionStack.slice(0),
                done: this.done
            };
            if (this.options.ranges) {
                backup.yylloc.range = this.yylloc.range.slice(0);
            }
        }

        lines = match[0].match(/(?:\r\n?|\n).*/g);
        if (lines) {
            this.yylineno += lines.length;
        }
        this.yylloc = {
            first_line: this.yylloc.last_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.last_column,
            last_column: lines ?
                         lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length :
                         this.yylloc.last_column + match[0].length
        };
        this.yytext += match[0];
        this.match += match[0];
        this.matches = match;
        this.yyleng = this.yytext.length;
        if (this.options.ranges) {
            this.yylloc.range = [this.offset, this.offset += this.yyleng];
        }
        this._more = false;
        this._backtrack = false;
        this._input = this._input.slice(match[0].length);
        this.matched += match[0];
        token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
        if (this.done && this._input) {
            this.done = false;
        }
        if (token) {
            return token;
        } else if (this._backtrack) {
            // recover context
            for (var k in backup) {
                this[k] = backup[k];
            }
            return false; // rule action called reject() implying the next rule should be tested instead.
        }
        return false;
    },

// return next match in input
next:function () {
        if (this.done) {
            return this.EOF;
        }
        if (!this._input) {
            this.done = true;
        }

        var token,
            match,
            tempMatch,
            index;
        if (!this._more) {
            this.yytext = '';
            this.match = '';
        }
        var rules = this._currentRules();
        for (var i = 0; i < rules.length; i++) {
            tempMatch = this._input.match(this.rules[rules[i]]);
            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
                match = tempMatch;
                index = i;
                if (this.options.backtrack_lexer) {
                    token = this.test_match(tempMatch, rules[i]);
                    if (token !== false) {
                        return token;
                    } else if (this._backtrack) {
                        match = false;
                        continue; // rule action called reject() implying a rule MISmatch.
                    } else {
                        // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
                        return false;
                    }
                } else if (!this.options.flex) {
                    break;
                }
            }
        }
        if (match) {
            token = this.test_match(match, rules[index]);
            if (token !== false) {
                return token;
            }
            // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
            return false;
        }
        if (this._input === "") {
            return this.EOF;
        } else {
            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(), {
                text: "",
                token: null,
                line: this.yylineno
            });
        }
    },

// return next match that has a token
lex:function lex() {
        var r = this.next();
        if (r) {
            return r;
        } else {
            return this.lex();
        }
    },

// activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
begin:function begin(condition) {
        this.conditionStack.push(condition);
    },

// pop the previously active lexer condition state off the condition stack
popState:function popState() {
        var n = this.conditionStack.length - 1;
        if (n > 0) {
            return this.conditionStack.pop();
        } else {
            return this.conditionStack[0];
        }
    },

// produce the lexer rule set which is active for the currently active lexer condition state
_currentRules:function _currentRules() {
        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
            return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
        } else {
            return this.conditions["INITIAL"].rules;
        }
    },

// return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
topState:function topState(n) {
        n = this.conditionStack.length - 1 - Math.abs(n || 0);
        if (n >= 0) {
            return this.conditionStack[n];
        } else {
            return "INITIAL";
        }
    },

// alias for begin(condition)
pushState:function pushState(condition) {
        this.begin(condition);
    },

// return the number of states currently on the stack
stateStackSize:function stateStackSize() {
        return this.conditionStack.length;
    },
options: {"case-insensitive":true},
performAction: function anonymous(yy,yy_,$avoiding_name_collisions,YY_START) {
var YYSTATE=YY_START;
switch($avoiding_name_collisions) {
case 0:return 5
break;
case 1:return 5
break;
case 2:return 'STRING'
break;
case 3:return 'STRING'
break;
case 4:return /* skip comments */
break;
case 5:return /* return 'COMMENT' */
break;
case 6:/* skip whitespace */
break;
case 7:return 30
break;
case 8:return 29
break;
case 9:return 26
break;
case 10:return 36
break;
case 11:return 43
break;
case 12:return 44
break;
case 13:return 35
break;
case 14:return 24
break;
case 15:return 27
break;
case 16:return 25
break;
case 17:return 28
break;
case 18:return 19
break;
case 19:return 55
break;
case 20:return 32
break;
case 21:return 47
break;
case 22:return 48
break;
case 23:return 41
break;
case 24:return 46
break;
case 25:return 'PERCENT'
break;
case 26:return 50
break;
case 27:return 49
break;
case 28:return 52
break;
case 29:return 54
break;
case 30:return 51
break;
case 31:return 53
break;
case 32:return 54
break;
case 33:return 31
break;
case 34:return 33
break;
case 35:return 37
break;
case 36:return 39
break;
case 37:return 40
break;
case 38:return 21
break;
case 39:return 'COLON'
break;
case 40:return 10
break;
case 41:return 'DOLLAR'
break;
case 42:return 'QUESTION'
break;
case 43:return 6
break;
case 44:return 4
break;
case 45:return 9
break;
case 46:return 'INVALID'
break;
}
},
rules: [/^(?:\[([^\]])*?\])/i,/^(?:`([^\]])*?`)/i,/^(?:(['](\\.|[^']|\\')*?['])+)/i,/^(?:(["](\\.|[^"]|\\")*?["])+)/i,/^(?:\/\*(.*?)\*\/)/i,/^(?:--(.*?)($|\r\n|\r|\n))/i,/^(?:\s+)/i,/^(?:AXIS\b)/i,/^(?:CHAPTERS\b)/i,/^(?:COLUMNS\b)/i,/^(?:EMPTY\b)/i,/^(?:FROM\b)/i,/^(?:HAVING\b)/i,/^(?:NON\b)/i,/^(?:ON\b)/i,/^(?:PAGES\b)/i,/^(?:ROWS\b)/i,/^(?:SECTIONS\b)/i,/^(?:SELECT\b)/i,/^(?:WHERE\b)/i,/^(?:(\d*[.])?\d+)/i,/^(?:\+)/i,/^(?:-)/i,/^(?:\*)/i,/^(?:\/)/i,/^(?:%)/i,/^(?:>=)/i,/^(?:>)/i,/^(?:<=)/i,/^(?:<>)/i,/^(?:<)/i,/^(?:=)/i,/^(?:!=)/i,/^(?:\()/i,/^(?:\))/i,/^(?:\{)/i,/^(?:\})/i,/^(?:\.)/i,/^(?:,)/i,/^(?::)/i,/^(?:;)/i,/^(?:\$)/i,/^(?:\?)/i,/^(?:&)/i,/^(?:[a-zA-Z_][a-zA-Z_0-9]*)/i,/^(?:$)/i,/^(?:.)/i],
conditions: {"INITIAL":{"rules":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46],"inclusive":true}}
});
return lexer;
})();
parser.lexer = lexer;
function Parser () {
  this.yy = {};
}
Parser.prototype = parser;parser.Parser = Parser;
return new Parser;
})();


if (typeof require !== 'undefined' && typeof exports !== 'undefined') {
exports.parser = parser;
exports.Parser = parser.Parser;
exports.parse = function () { return parser.parse.apply(parser, arguments); };
exports.main = function commonjsMain(args) {
    if (!args[1]) {
        console.log('Usage: '+args[0]+' FILE');
        process.exit(1);
    }
    var source = require('fs').readFileSync(require('path').normalize(args[1]), "utf8");
    return exports.parser.parse(source);
};
if (typeof module !== 'undefined' && require.main === module) {
  exports.main(process.argv.slice(1));
}
}

/*
//
// Main class for Alamdx.js
// Date: 23.11.2014
// (c) 2014, Andrey Gershun
//
*/


// Initial parameters
alamdx.parser = parser;
alamdx.parse = parser.parse.bind(parser); // Shortcut

// Deafult options
alamdx.options = {};


// Run one statement
alamdx.exec = function (sql, params, cb) {
	return alasql.dexec(alasql.useid, sql, params, cb);
}

alamdx.dexec = function (databaseid, sql, params, cb) {
	var db = alasql.databases[databaseid];

	// Create AST
	var ast = alamdx.parse(sql);
	console.log(ast);

	if(!ast.statements) return;
	if(ast.statements.length == 0) return 0;
	else if(ast.statements.length == 1) {
		return ast.statements[0].execute(databaseid, params, cb);		
	} else {
		// Multiple statements
		return alamdx.drun(databaseid, ast, params, cb);
	}
};

// Run multiple statements and return array of results
alamdx.drun = function (databaseid, ast, params, cb) {
	var useid = alasql.useid;
	if(useid != databaseid) alasql.use(databaseid);
	var res = [];
	for (var i=0, ilen=ast.statements.length; i<ilen; i++) {
		if(ast.statements[i]) {
//			if(alamdx.options.logstatements) console.log(ast.statements[i].toString());
			res.push(ast.statements[i].execute(alasql.useid, params));
		}
	};
	if(useid != databaseid) alasql.use(useid);
	if(cb) cb(res);
	return res;
};



/*
//
// Last part of Alasql.js
// Date: 03.11.2014
// (c) 2014, Andrey Gershun
//
*/

// End of module


// Create default database


return alamdx;
}));


//# sourceMappingURL=alamdx.js.map